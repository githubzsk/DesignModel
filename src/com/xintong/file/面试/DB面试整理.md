# 数据库面试

##### 1 事务（Transaction）及其ACID属性

事务是由一组SQL语句组成的逻辑处理单元,事务具有以下4个属性,通常简称为事务的ACID属性

- 原子性(Atomicity) ：事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行
- 在事务开始和完成时,数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改,以保持数据的完整性;事务结束时,所有的内部数据结构(如B树索引或双向链表)也都必须是正确的
- 数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的,不能影响到其他事务的操作。
- 事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。

##### 2 数据库锁的分类

- 从性能来说，可以分为乐观锁悲观锁
- 从粒度来说的话可分为行锁和表锁
- 从对数据库操作类型分类又可以分为读锁和写锁

##### 3 脏读 幻读 不可重复读

- 脏读： A事务中读到了B事务未提交的数据，并且在这个基础上做了操作，然后B事务回滚，这个时候A读到的数据就是脏数据，脏读必然会导致违反了ACID中的C一致性

- 不可重读读：指的是同一事物内相同的查询得到了不同的结果，主要针对的update操作

  A事务开始查询到结果1，B事务对该数据执行事务并提交，A事务再次查询变成结果2

- 幻读：在同一个事务内，相同的查询却得到了不同的数量，针对的是insert操作，这是网上绝大部分技术博客对幻读的描述，但是同样的其他事务update操作，也可以造成两次查询结果不一样

##### 4 事务的隔离级别

- 读未提交（Read uncommitted）

  这种隔离级别事务能读到其他事务未提交的数据，会造成脏读

- 读已提交

  可以解决脏读

- 可重复读

  可以解决脏读、不可重复读

- 串行化

  可以解决脏读、不可重复读、幻读

##### 5 char和varchar的区别

- char定长，所以在效率上高一点
- varchar长度不固定，所以效率差一点，但是不会存在资源浪费

##### 6 如何理解索引

索引是帮助MySQL高效获取数据的排好序的数据结构

##### 7*Mysql索引类型

- 聚集索引（聚簇索引）：表中的列的顺序和数据的物理地址顺序是完全一样的

  表中数据的物理顺序与索引的的顺序是一致的，换句话说找到了主键也就找到了数据

  **数据的存储位置和主键是在一起的，找到了主键也就找到了数据**

  InnoDB中的索引是聚集索引

  InnoDB中的主键索引 key-data中 key储存索引信息 data储存数据信息

  InnoDB中的非主键索引 key-data 中的key储存的是索引信息 data存储主键

- 非聚集索引：表中列的数据和物理存储中的数据顺序不同

  **数据的存储位置和主键没在一起，根据主键中存的地址再去找数据**
  
  MyISAM中的索引主键/辅助索引都是非聚集索引，最底层的每个叶子节点里面 key-data这种形式，key是主键而data是相应的数据的指针
  
  主键索引 非主键索引 唯一索引 单列索引 组合索引

##### 8 为什么InnoDB必须有主键而且最好自增

为何必须有主键？

首先讲InnoDB主键索引和非主键索引原理（参考以上）因为InnoDB的非主键索引要依赖主键索引，主键索引依赖主键，一旦没有主键，也就没有主键索引，也就无法实现任何索引，所以如果InnoDB不设置主键索引的话，他会找一个不含null值的唯一索引作为主键索引，如果不存在这样的，那么他会生成一个隐含的主键并创建主键索引

为何最好自增？

主要是考虑到对性能的影响，自增的话有规律，按照b+树的排序，某一页写完写下一页，不自增的话在磁盘上的写的位置会不断来回跳没有顺序没有规律，性能消耗大

##### 9 为什么非主键叶子结点存储主键值

便于维护，一旦行移动或者数据页分裂，二级索引不需要修改，主需要修改主键索引（聚集索引）

一致性和节省空间

##### 10 *创建索引的依据

应该创建的情况

- where 后边频繁出现的字段，就可以考虑创建索引
- 经常做连接的表，在连接字段上创建索引

不应该创建的情况      

- 字段中数据重复性高，去极端情况数据全都一样，加了和没加一样，跟全表扫描没有区别
- 频繁更新的字段不要使用索引，频繁改变会导致索引页频繁变化导致数据库压力变大

##### 11 *什么情况下索引失效

- like可能会引失效：like左边如果也加上%，会导致索引失效
- or/or可能会引失效：作用于非主键字段的话必然失效、作用于主键字段的话可能会失效，具体跟数量有关Mysql内部会进行优化
- 没有遵守最左前缀法则
- where中索引列有计算、函数、类型转换
- 触发了类型隐式转换


##### 12 覆盖索引

只查询创建了索引的相关列的字段，这种情况下效率会很好，因为他直接从索引中拿值不走数据表

 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。

覆盖索引优化实例

```mysql
-- 其中 id主键  name加了单列索引  这样下来走了覆盖索引，效率高 
EXPLAIN SELECT  a.id,a.`name` FROM `user` a WHERE a.`name` = 'aaa' -- Using index

-- 其中 age无索引 会导致回表查询age，效率较差 using index condition
EXPLAIN SELECT  a.id,a.`name`,a.age FROM `user` a WHERE a.`name` = 'aaa'

-- 可以将 name、age设计成联合索引 这样便不会回表，提高效率
```

##### 13 *数据库性能优化

个人感觉合适的使用索引能解决至少70-80%的问题，剩下的问题就考虑sql的优化，在考虑数据表设计的是否合理，再考虑分表

##### 14 *分表主键怎么设计

可以考虑使用snowflake 算法

##### 15 *批量导入MySql1000万条数据，实现思路/大量数据插入数据库速度慢如何优化 

如果说是大批量数据单条提交的话必然会慢，可以考虑将数据合并成批量插入，使用StringBuffer去拼接，比如说我10/20/30W次分一个事务提交一次，这样下来肯定会比单条要快好多

##### 16 *数据库乐观锁悲观锁有用过吗，实现？

乐观锁：一般利用表字段的version+1来实现（如SVN、GIT提交代码就是这样的）

悲观锁：一般是 where id=XX for update 来实现 （一般银行转账、工单审批

- 

##### 17 *行锁跟表锁区别 

- **表锁**：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低
  - 加读锁：当前session和其他session都能读，当前session执行增删改会报错，其余session增删改会阻塞
  - 加写锁：当前session随意增删改查，而其他session的所有操作都会被阻塞
- **行锁**：开销大，加锁慢，会出现死锁。锁力粒度小，发生锁冲突的概率小，并发度最高

##### 18 * 为什么用B+树，不用其他类型

**先说二叉树系列**

不管你平衡二叉树、二叉搜索树还是红黑树，只要你属于二叉树，每个节点必然最多只有两个子节点，那么在数据量一大，树的高度是比较大的，而磁盘进行差查找的次数往往取决于树的高度，而磁盘存取原理是这样的**磁盘存取原理**，所以呢，因为树的高度，所以二叉树系列肯定是不合适的

**再说B树**

- B树呢他的所有叶子节点的高度都是完全一样的

- 而且每个节点可以有多个子节点，这个就避免了二叉树哪种树太高而导致多次IO的情况

- 另外它的每个节点上都存有数据，有可能根节点直接找到，有可能在某个叶节点找到，所以这也就导致了如果使用B树做索引，查询的不稳定性，

  最致命的原因是，B树做精准查询确实是没问题的，但是要做范围查询的话，因为他每个数据之间并没有联系，比如你查一个>8的所有数字，比如我有1000个，那我还得做好几千次IO，这肯定是不能接受的

**再说Hash**

实际上Mysql也是支持Hash做索引，不过局限性比较大，精确查询确实是没有问题，但是不能用它做范围查询

**最后再说B+树**

B+树在B树的基础上做了些改变，首先他的非叶子节点不存数据只存key，它的度能更大，也就意味着树的高度更矮，所有的数据只存在于树顶的叶子节点，而且更重要的是，数据之间存有前后的指针，可以看做是一个链表，我只要拿到了你，我就能很简单的拿到你的下一个，基于这个原因解决了范围查找的问题，所以说B+树相比去其他类型，更合适

##### 19 Myisam和innodb区别

MyISAM：**不支持事务** 不支持外键 可以没有主键 表锁  三个文件

InnoDB：**支持事务** 支持外键 必须有主键 行锁 两个文件



##### 20 磁盘读取原理



![在这里插入图片描述](https://img-blog.csdnimg.cn/20200513164708431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzAxMjkzNw==,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200513164719864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzAxMjkzNw==,size_16,color_FFFFFF,t_70)

- 寻道时间(速度慢，费时)
- 旋转时间(速度较快)

磁盘读取分为两步骤。首先寻道，磁头由内向外或者由外向内移动寻找相应的磁道，接着旋转，磁盘旋转到对应的扇区然后再读取数据，而寻道的这个过程是比较耗时的，这个可以从硬件层面去解释为什么很多时候IO会是系统的瓶颈

##### 21.left join，right join，inner join

- left join：以左表为主表全部显示，右表是匹配上的显示
- right join：与上相反
- inner join：取交集，双方都匹配上的显示

##### 22.MySQL默认隔离级别，为什么，你们项目用什么？

默认可重复读，

mysql在读已提交下做主从复制存在Bug，所以选用可重复读

项目用读以已提交

- 可重复读RR（Repeatable Read） 存在间隙锁 导致其他事务无法提交  读已提交RC 不存在间隙锁
- RR（Repeatable Read）未命中索引行会锁表，RC（Repeatable Commited）只锁行

为什么不用读未提交和串行化

- 读未提交可能会产生脏读，从逻辑上就说不过去
- 串行化，会对每次操作都加锁，严重影响性能







