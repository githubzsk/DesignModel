# 项目杂谈

##### 1 *线上问题oom

##### 2 *设计接口幂等性 

解决幂等性的本质就是通过各种校验，对于相同的资源不让他执行重复的动作

1. Redis+token
2. 状态机 where status = 期望的原来的status
3. 乐观锁
   - 查询数据得到版本号 version = 1
   - 在执行更新 update xxx set money = money + 100，version = version+1 where id = 1 and version = 1
4. 全局唯一编号，编号重复直接返回
5. 基于数据库做唯一主键
6. 基于数据库做唯一索引

##### 3 *第三方接口调用系列

##### 4 *分布式的缺点

##### 5 *服务器端防止表单重复提交

产生场景

- 在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交
- 表单提交后用户点击【刷新】按钮导致表单重复提交
- 用户提交表单后，点击浏览器的【后退】按钮回退到表单页面后进行再次提交

场景一 ：浏览器端点击一次后禁用提交

场景二 : 可是考虑使用重定向，重定向是二次请求，不在一个request和response内

场景三 : 可以考虑Session中存token，token匹配上就执行，token匹配不上就是重复提交(接口幂等)

##### 6 *项目中打日志的框架，错误日志如何配置

##### 7 *Session和Cooking区别

Cookie和Session都是服务器进行状态管理的产物

Cookie是将数据保存在浏览器，大小和数量都有限制，安全性不高

Session把信息存在服务端，基于Cookie传递SessionID，从而实现状态管理

##### 8 *get和post的区别

get 点击某个连接 form默认提交都是get 数据会携带在url中不安全，而且大小比较小

post 会将数据放在body中，安全性相对来说比较高，而且数据量也比较大 

##### 9 *减去库存问题处理

##### 10 *重复支付

##### 11 **日志怎么打，有什么规范**

##### 12**枚举场景**

##### 13. 转发重定向

重定向：服务器通知浏览器去访问另一个任意地址，状态码302，location消息头中保存重定向地址，是二次请求

转发：一个Web组件把没干完的事交给另外一个Web组件去做，在同一个请求响应之内



##### 14.红黑树

- 根节点黑色
- 所有的节点不是红色就是黑色
- 红色节点的叶节点必须是是黑色
- 任一节点到其叶子结点的路径包含的黑节点数目相同

